package zswagger

import (
	"encoding/json"
	"net"
	"net/http"
	"net/url"
	"reflect"
	"sort"
	"strconv"
	"strings"
	"time"

	"github.com/go-openapi/spec"

	"github.com/go-zing/gozz-kit/internal/helpers"
	"github.com/go-zing/gozz-kit/zapi"
	"github.com/go-zing/gozz-kit/zdoc"
)

const (
	definitionsPrefix = "#/definitions/"
	extensionKeyOrder = "x-order"

	description = "This file is generated by [gozz-kit-zswagger](https://github.com/go-zing/gozz-kit/tree/main/zapi/zswagger)."
)

var (
	escapeReplacer = strings.NewReplacer("/", "_")

	defined = map[reflect.Type]func(*spec.Schema){
		reflect.TypeOf(net.IP{}):          func(schema *spec.Schema) { schema.Typed("string", "ipv4") },
		reflect.TypeOf(time.Time{}):       func(schema *spec.Schema) { schema.Typed("string", "date-time") },
		reflect.TypeOf(url.URL{}):         func(schema *spec.Schema) { schema.Typed("string", "uri") },
		reflect.TypeOf([]byte(nil)):       func(schema *spec.Schema) { schema.Typed("string", "base64") },
		reflect.TypeOf(json.RawMessage{}): func(schema *spec.Schema) { schema.Typed("object", "") },
		reflect.TypeOf(struct{}{}):        func(schema *spec.Schema) { schema.Typed("null", "") },
	}
)

func RegisterSchemaType(typ reflect.Type, fn func(*spec.Schema)) { defined[typ] = fn }

func escape(str string) string { return escapeReplacer.Replace(str) }

//go:generate gozz run -p "option" .
type (
	schemaParser struct {
		option      Option
		payloads    map[reflect.Type]*zapi.PayloadType
		definitions spec.Definitions
	}

	// +zz:option
	Option struct {
		HttpCast func(api zapi.Api) zapi.HttpApi
		Bindings map[string]Binding
		DocFunc  func(reflect.Type, string) string
	}

	Binding struct {
		Path   string
		Query  string
		Header string
		Body   bool
	}
)

func refSchema(name string) spec.Schema {
	return spec.Schema{SchemaProps: spec.SchemaProps{Ref: spec.MustCreateRef(definitionsPrefix + name)}}
}

func parseBinding(api *zapi.HttpApi, rules map[string]Binding) Binding {
	rule, ok := rules[strings.ToUpper(api.Method)]
	if !ok {
		return rules["*"]
	}
	rv := reflect.ValueOf(&rule).Elem()
	for i := 0; i < rv.NumField(); i++ {
		v, valid := rv.Field(i).Addr().Interface().(*string)
		if !valid {
			continue
		}
		if ref, exist := rules[strings.ToUpper(*v)]; exist {
			*v = reflect.ValueOf(ref).Field(i).String()
		}
	}
	return rule
}

func parseElements(payloads map[reflect.Type]*zapi.PayloadType, root *zapi.PayloadType, tag string, fn func(zapi.PayloadElement, zapi.TagValues)) {
	if len(tag) == 0 {
		return
	}
	delete(payloads, root.Type)
	for _, ele := range root.Elements {
		typ, ok := payloads[ele.Type]
		if !ok {
			continue
		}
		values := ele.Tags.Get(tag).Split(",")
		value := values[0]
		if value == "-" {
			continue
		} else if ele.IsAnonymous() && len(value) == 0 && typ.Kind == reflect.Struct {
			parseElements(payloads, typ, tag, fn)
		} else {
			fn(ele, values)
		}
	}
}

func setOperation(paths map[string]spec.PathItem, method, path string, operate spec.Operation) {
	item := paths[path]
	fieldName := strings.Title(strings.ToLower(method))
	if v := reflect.ValueOf(&item).Elem().FieldByName(fieldName); v.IsValid() {
		v.Set(reflect.ValueOf(&operate))
		paths[path] = item
	}
}

func Parse(iterator zapi.Iterator, option ...func(*Option)) (swagger *spec.Swagger) {
	opt := Option{}
	opt.applyOptions(option...)
	groups, payloads := zapi.NewParser(zapi.WithDocFunc(opt.DocFunc)).Parse(iterator)

	rt := helpers.IndirectType(reflect.TypeOf(iterator))
	swagger = &spec.Swagger{
		SwaggerProps: spec.SwaggerProps{
			Info: &spec.Info{InfoProps: spec.InfoProps{
				Description: description,
				Title:       rt.PkgPath() + "." + rt.Name(),
				Version:     "unknown",
			}},
			Schemes:     []string{"http"},
			Swagger:     "2.0",
			Paths:       &spec.Paths{Paths: make(map[string]spec.PathItem)},
			Definitions: make(map[string]spec.Schema),
		},
	}

	parser := &schemaParser{definitions: swagger.Definitions, payloads: payloads, option: opt}

	for _, group := range groups {
		swagger.Tags = append(swagger.Tags, spec.NewTag(group.Fullname(), group.Doc, nil))
		for _, api := range group.Apis {
			h := parser.httpCast(api)
			h.Method = strings.ToUpper(h.Method)
			h.Path = "/" + strings.TrimPrefix(h.Path, "/")
			setOperation(swagger.Paths.Paths, h.Method, h.Path, parser.parseOperation(&group, &h))
		}
	}
	return
}

func (p *schemaParser) httpCast(api zapi.Api) (h zapi.HttpApi) {
	if p.option.HttpCast != nil {
		return p.option.HttpCast(api)
	}
	sp := strings.SplitN(api.Resource, "|", 2)[:2]
	return zapi.HttpApi{
		Api:    api,
		Method: sp[0],
		Path:   sp[1],
	}
}

func (p *schemaParser) parseBinding(h *zapi.HttpApi) Binding {
	return parseBinding(h, p.option.Bindings)
}

func (p *schemaParser) parseOperation(group *zapi.ApiGroup, api *zapi.HttpApi) (o spec.Operation) {
	// meta info
	o.ID = group.Fullname() + "." + api.Name
	o.Description = api.Doc
	o.Tags = append(o.Tags, group.Fullname())
	// parse params
	o.Parameters = p.parseParams(api, p.parseBinding(api))
	// parse response
	if payload := p.payloads[api.Response]; payload != nil {
		schema := p.Parse(payload)
		o.RespondsWith(http.StatusOK, spec.NewResponse().WithSchema(&schema))
	}
	return
}

func (p *schemaParser) parseParams(api *zapi.HttpApi, binding Binding) (params []spec.Parameter) {
	added := make(map[string]int)

	addParam := func(param *spec.Parameter) {
		if _, exist := added[param.Name]; !exist && len(param.Type) > 0 && len(param.Name) > 0 {
			added[param.Name] = len(params)
			params = append(params, *param)
		}
	}

	for _, path := range strings.Split(api.Path, "/") {
		if strings.HasPrefix(path, "{") && strings.HasSuffix(path, "}") {
			name := strings.TrimSuffix(strings.TrimPrefix(path, "{"), "}")
			addParam(spec.PathParam(name).Typed("string", ""))
		}
	}

	if api.Request != nil && api.Request.Kind() == reflect.Struct {
		parsePayload := func(tag string, fn func(element zapi.PayloadElement, values zapi.TagValues)) {
			cp := make(map[reflect.Type]*zapi.PayloadType, len(p.payloads))
			for k, v := range p.payloads {
				cp[k] = v
			}
			parseElements(cp, cp[api.Request], tag, func(element zapi.PayloadElement, values zapi.TagValues) {
				if len(values[0]) > 0 {
					fn(element, values)
				}
			})
		}

		newWith := func(in string) func(element zapi.PayloadElement, values zapi.TagValues) {
			return func(element zapi.PayloadElement, values zapi.TagValues) {
				param := &spec.Parameter{ParamProps: spec.ParamProps{Name: values[0], In: in}}
				param.Description = element.Doc
				param.Typed(parseBasicKind(element.Type.Kind()))
				addParam(param)
			}
		}

		parsePayload(binding.Path, func(element zapi.PayloadElement, values zapi.TagValues) {
			if index, ok := added[values[0]]; ok {
				param := &params[index]
				param.Description = element.Doc
				param.Typed(parseBasicKind(element.Type.Kind()))
			}
		})

		parsePayload(binding.Query, newWith("query"))
		parsePayload(binding.Header, newWith("header"))
	}

	if payload := p.payloads[api.Request]; payload != nil && binding.Body {
		schema := p.Parse(payload)
		params = append(params, *spec.BodyParam("", &schema).Named("body"))
	}
	return
}

func (p *schemaParser) Parse(typ *zapi.PayloadType) (schema spec.Schema) {
	name := escape(typ.Fullname())
	if _, ok := p.definitions[name]; ok {
		return refSchema(name)
	}
	return p.parseTypeSchema(typ)
}

func (p *schemaParser) parseEmbedProperties(ele zapi.PayloadElement, schema *spec.Schema) {
	embed := p.Parse(p.payloads[ele.Type])
	if ref := embed.Ref.String(); len(ref) > 0 {
		embed = p.definitions[strings.TrimPrefix(ref, definitionsPrefix)]
	}
	required := make(map[string]bool, len(embed.Required))
	for _, req := range embed.Required {
		required[req] = !ele.IsPointer()
	}
	keys := make([]string, 0, len(embed.Properties))
	for key := range embed.Properties {
		if _, exist := schema.Properties[key]; !exist {
			keys = append(keys, key)
		}
	}
	sort.Slice(keys, func(i, j int) bool {
		orderI, _ := embed.Properties[keys[i]].Extensions.GetInt(extensionKeyOrder)
		orderJ, _ := embed.Properties[keys[j]].Extensions.GetInt(extensionKeyOrder)
		return orderI < orderJ
	})
	for _, key := range keys {
		property := embed.Properties[key]
		addElementProperty(schema, &property, key, required[key])
	}
}

func addElementProperty(dst, property *spec.Schema, key string, required bool) {
	property.AddExtension(extensionKeyOrder, strconv.Itoa(len(dst.Properties)))
	if dst.SetProperty(key, *property); required {
		dst.AddRequired(key)
	}
}

func (p *schemaParser) parseElementProperty(ele zapi.PayloadElement, schema *spec.Schema) {
	values := ele.Tags.Get("json").Split(",")
	key := values[0]
	typ := p.payloads[ele.Type]

	if key == "-" {
		return
	} else if ele.IsAnonymous() && typ.Kind == reflect.Struct && len(key) == 0 {
		p.parseEmbedProperties(ele, schema)
		return
	} else if len(key) == 0 {
		key = ele.Name
	}

	// parse property
	property := p.Parse(typ)

	// title description
	property.Title, property.Description = zdoc.Split(ele.Doc)

	// combine ref with allOf
	if ref := property.Ref; len(ref.String()) > 0 {
		property.Ref = spec.Ref{}
		property.AddToAllOf(spec.Schema{SchemaProps: spec.SchemaProps{Ref: ref}})
	}

	// add to schema properties
	addElementProperty(schema, &property, key, !ele.IsPointer() && !values.Exist("omitempty"))
}

func (p *schemaParser) parseTypeSchema(typ *zapi.PayloadType) (schema spec.Schema) {
	if len(typ.Package) > 0 && !helpers.IsGoStandardPackage(typ.Package) {
		name := escape(typ.Fullname())
		p.definitions[name] = schema
		defer func() { p.definitions[name] = schema; schema = refSchema(name) }()
	}

	schema.Title, schema.Description = zdoc.Split(typ.Doc)
	schema.Example = typ.Entity

	if define, ok := defined[typ.Type]; ok {
		if define(&schema); len(schema.Type) > 0 {
			return
		}
	}

	switch typ.Kind {
	case reflect.Interface:
		schema.Nullable = true
	case reflect.Struct:
		schema.Typed("object", "")
		for _, ele := range typ.Elements {
			p.parseElementProperty(ele, &schema)
		}
	case reflect.Map:
		schema.Typed("object", "")
		schema.SetProperty(".*", p.Parse(p.payloads[typ.Elements[0].Type]))
	case reflect.Slice, reflect.Array:
		schema.Typed("array", "")
		itemSchema := p.Parse(p.payloads[typ.Elements[0].Type])
		schema.Items = &spec.SchemaOrArray{Schema: &itemSchema}
	default:
		schema.Typed(parseBasicKind(typ.Kind))
	}
	return
}

func parseIntegerKind(kind string) (typ, format string) {
	format = kind
	unsigned := helpers.Btoi[strings.HasPrefix(kind, "u")]
	size := strconv.IntSize
	if ss := strings.TrimPrefix(kind[unsigned:], "int"); len(ss) > 0 {
		size, _ = strconv.Atoi(ss)
	} else {
		format += strconv.Itoa(size)
	}
	return "integer", format
}

func parseBasicKind(k reflect.Kind) (typ, format string) {
	switch kind := k.String(); k {
	case reflect.Bool:
		return "boolean", ""
	case reflect.String:
		return "string", ""
	case reflect.Float32, reflect.Float64:
		return "number", kind
	default:
		if strings.Contains(kind, "int") {
			return parseIntegerKind(kind)
		}
	}
	return
}
